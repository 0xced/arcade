# Staged release process

With the data we have in BAR we know about what each repo's builds, what does it depend on, SHAs, 
how far a given commit is from HEAD, etc. Also, with channels we can define the intention of the builds.

From the above mentioned, we could create a release flow where builds are promoted to different channels/stages 
and in each have different sets of operations and validations.

Tasks different from building and signing will be executed as part of Azure DevOps Release Definitions that will be
triggered by Maestro++ after a set of builds are assigned to a channel. This might change in the future as we migrate
release definition tasks to Azure DevOps stages.

## Release Stages

### Dev (.NET Core 3 Dev channel)

1. Standard builds after merges into master branch
2. Sign produced packages by the build
3. Signing validation*
4. Symbol publishing to symweb and MSDL*
5. Symbol availability validation*
6. Publish packages, installers, packages, etc. to dotnet feeds and MyGet*
7. **(Future)** source build

**Promotion:** Tactics decision and coordinated activities driven by the repos to snap release branches from master and 
begin the release stabilization process. 

*Currently only available on asyn release pipelines

### Release (.NET Core 3 Release channel)

1. Standard builds after merges into release/* branch
2. Sign produced packages by the build
3. Signing validation *
4. Symbol publishing to symweb and MSDL*
5. Symbol availability validation *
6. Publish packages, installers, packages, etc. to dotnet feeds and MyGet*
7. Gather drop and send to CTI for validation
8. Take PRs to fix found issues, rinse and repeat

**Promotion:** 
1. CTI sign off
2. Version is coherent 
3. Tactics approve this version
4. Move all related builds to the Release Validation channel

*Not yet in an async release definition but will mimic what we have in the previous stage.

### Final Validation (Release Validation channel)

1. No build required
2. Redhat source build
3. Antares: set of zips used to deploy to Azure App Services for the SDK, Runtime and ASP. SDK and Runtime are generated by a 
post-build script. Zips are validated by the ASP team against an App Services test environment
4. Push packages to Nuget INT by pushing all the things that would end up in nuget.org
5. Stage final drop and binary validation making sure we have all that we need

**Promotion:** 
1. All the previous validation steps succeed
2. Tactics approve this version
3. Move all related builds to the Publish Release channel

### Final Release/Publish (Publish Release channel)
 
1. No build required
2. Publish and validate NuGet symbols
3. Publish and validate Linux distributions
3. Antares deployment
4. Publish and validate Docker
5. Publish Docs
6. Publish and validate to NuGet
7. Publish and validate to CDN